提取购物车内容逻辑
	数据库
	1. 表:shoppingcat 购物车, 每个第一次添加商品到购物车时生成一个, 生成订单后应该会删除吧. 同时表中有customer(用户编号)字段, 可以得到用户信息.
	2. 表:shoppingcat_item 购物车内的商品
	
	前台
	1. 在cookie中有一个c字段, 保存了shoppingcat的ID
	
	后台
	1. 重新读取购物车里面的内容
		1.1. 通过cookie里面的shoppingcat取到shoppingcat以及购物车里面的商品.
	
	相关类
	1. 拦截并生成shoppingcat ec-core\src\main\java\com\winxuan\ec\support\interceptor\ParameterArgumentResolver.java  P80
	2. shoppingcat service  ec-core\src\main\java\com\winxuan\ec\service\shoppingcart\ShoppingcartServiceImpl 


显示购物车逻辑
	1. 参见<添加商品到购物车>步骤4

购物车设置促销信息
	1. 提取商品组
		1.1 根据商品所在shop以及商品的供应类别(正常销售,新品预售,订购)生成一个shoppingSeparator(购物车分隔符)
		1.2 将商品添加到对应的组别中
	2. 得到拆分的销售价格
		2.1 提取商品组
		2.2 遍历并计算商品组中每个商品的总销售价
			2.2.1 总销售价计算公式: 商品销售价 * 商品数量
	3. 查询当前生效的订单促销活动
		3.1 开始时间不大于当前时间
		3.2 结束时间不小于当前时间
		3.3 状态为审核通过
		3.4 类型为订单类型的促销
	4. 遍历商品组
		4.1 查询出各个组各个商品的买赠的促销信息
			4.1.1 开始时间小于当前时间
			4.1.2 结束时间大于当前时间
			4.1.3 状态为审核通过
			4.1.4 活动类别为买赠
			4.1.5 当前组所有的商品
		4.2 如果有买赠, 那就提取出每个促销中的参与商品, 以及赠送商品的信息,加上该商品的数量.
			4.2.1 促销(promotion)中有个productRules字段, 它将所有这个促销的正式商品,赠送商品都保存在(promotion_productrule)表中.
		4.3 如果购物车中的商品数小于促销商品量时遍历赠送商品
			4.3.1 根据是否可以重复赠送(促销信息的replication属性)计算出赠品的赠送数量
			4.3.2 根据可用量判断赠送商品数, 并添加到shoppingcartItem的gifts(不存数据库)字段中.
	5. 取到商品组总价格
	6. 遍历订单促销活动
		6.1 根据商品组的shop信息判断是否参与订单促销
			6.1.1 在promotion里面有一个shops字段, 空的话参与非空则判断参与的商店
		6.2 满省
			6.2.1 普通优惠: 提取PromotionOrderRule(促销规则)的第一项做为参考,使用多次满省的规则, 例:满10省2,买了99则 99/10 = 9, 9 * 2 = 18最后就省下18元
			6.2.2 梯度优惠: 递归promotionOrderRule, 直到找到满足当前金额的规则时才使用相应的优惠政策.
		6.3 满送卷(子规则与满省差不多)



添加商品到购物车
	1. 遍历添加的商品. 
	2. 判断商品是否销售
	3. 判断商品可用量是否大于销售量,不管是否大于, 都会添加到购物车里面,然后保存到数据库中, 可能是前台做了什么处理吧.不然这里应该会出问题.<可用量计算公式:库存数量(stockQuantity) - 销售占用数量(saleQuantity)>
	4. 设置促销信息,参见上面的<设置促销信息>
	5. 将shoppingcat里面的商品数保存到cookie中
	6. 相关表及字段
		6.1 promotion 促销信息表
		6.2 promotion_productrule 参与促销的商品, 包括正式商品与赠送商品
		6.3 promotion_orderrule 促销规则, 最低消费, 赠送金额等


选择订单逻辑(提交购物车)
	1. 判断购物车是否为空, 为空返回购物车
	2. 判断购物车里的商品的商家,销售类型是否相同, 相同的话进入确认订单, 否则进入选择订单界面选择商家,销售类型相同的一组然后进入确认订单界面
